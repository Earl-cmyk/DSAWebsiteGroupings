{% extends "base.html" %}
{% block title %}DSAWebLectures{% endblock %}
{% block styles %}
{{ super() }}
<style>
#diagram-svg {
  background: #0a0e17;
  border-radius: 12px;
  width: 100%;
  height: 400px;
  max-width: 100%;
  overflow: hidden;
  display: block;
  margin: 0 auto;
}

#diagram-display {
  width: 100%;
  border: 1px solid #2d3748;
  padding: 10px;
  box-sizing: border-box;
  overflow: hidden;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}

.block rect {
  fill: #1e3a8a;
  rx: 8;
  cursor: grab;
}

.block text {
  fill: white;
  font-size: 14px;
  text-anchor: middle;
  dominant-baseline: middle;
  pointer-events: none;
}

.link {
  stroke: white;
  stroke-width: 3;
  fill: none;
}
</style>
{% endblock styles %}
{% block content %}
<div id="bg-grid"></div>

<article class="post-card">
  <header>
    <h3 class="post-title">Block Diagram Builder</h3>
    <p class="post-caption">Linear block diagram with auto-aligned connections.</p>
  </header>

  <div style="margin:10px 0;display:flex;gap:.5rem;">
    <input id="block-label" placeholder="Block label…" />
    <button id="add-block">Add Block</button>
    <button id="export-png">Export PNG</button>
  </div>

  <div id="diagram-display">
    <svg id="diagram-svg" viewBox="0 0 900 400" preserveAspectRatio="xMinYMin meet">
    </svg>
  </div>
</article>
{% endblock content %}

{% block scripts %}
<script>

const svg = document.getElementById("diagram-svg");
const svgContainer = document.getElementById("diagram-display");
const GRID_Y = 150; // Moved down to give more space
let BLOCK_W = 150;  // Default width
let BLOCK_H = 50;   // Default height
let selectedBlock = null;
let drawing = null; // { from, path }
let blocks = [];
let links = [];
let drag = null;

function connect(a, b) {
  const path = document.createElementNS(svg.namespaceURI, "path");
  path.classList.add("link");
  svg.insertBefore(path, svg.firstChild);

  const link = { a, b, path };
  links.push(link);
  updateLink(link);
}

function updateLink(l) {
  const x1 = l.a.x + BLOCK_W;
  const y1 = GRID_Y;

  const x2 = l.b.x;
  const y2 = GRID_Y;

  // no obstacle → straight
  if (!hasBlockBetween(l.a, l.b)) {
    l.path.setAttribute("d", `M ${x1} ${y1} L ${x2} ${y2}`);
    return;
  }

  // obstacle detected → route ABOVE
  const offsetY = GRID_Y - 60;
  const midX = (x1 + x2) / 2;

  l.path.setAttribute(
    "d",
    `M ${x1} ${y1}
     L ${x1} ${offsetY}
     L ${x2} ${offsetY}
     L ${x2} ${y2}`
  );
}

function hasBlockBetween(a, b) {
  const left = Math.min(a.x + BLOCK_W, b.x);
  const right = Math.max(a.x, b.x + BLOCK_W);

  return blocks.some(o => {
    if (o === a || o === b) return false;
    return o.x < right && o.x + BLOCK_W > left;
  });
}

function createBlock(label) {
  const index = blocks.length;
  
  const g = document.createElementNS(svg.namespaceURI, "g");
  g.classList.add("block");

  const rect = document.createElementNS(svg.namespaceURI, "rect");
  rect.setAttribute("y", GRID_Y - BLOCK_H / 2);
  rect.setAttribute("width", BLOCK_W);
  rect.setAttribute("height", BLOCK_H);

  const text = document.createElementNS(svg.namespaceURI, "text");
  text.setAttribute("y", GRID_Y);
  text.textContent = label || `Block ${index + 1}`;

  g.append(rect, text);
  svg.appendChild(g);

  const block = { g, rect, text, x: 0 }; // x will be set in layoutBlocks
  blocks.push(block);

  rect.addEventListener("mousedown", e => {
    e.stopPropagation();

    // SHIFT = move block
    if (e.shiftKey) {
      drag = block;
      return;
    }

    // start drawing line
    const path = document.createElementNS(svg.namespaceURI, "path");
    path.classList.add("link");
    svg.insertBefore(path, svg.firstChild);

    drawing = { from: block, path };
  });

  // Update layout for all blocks
  layoutBlocks();
}

function clearSelection() {
  blocks.forEach(b => {
    b.rect.style.stroke = "none";
  });
  selectedBlock = null;
}

function redraw() {
  links.forEach(updateLink);
}

function updatePreviewLine(path, x, y) {
  const x1 = drawing.from.x + BLOCK_W;
  const y1 = GRID_Y;

  // close enough → straight preview
  if (Math.abs(y - y1) < 15) {
    path.setAttribute("d", `M ${x1} ${y1} L ${x} ${y1}`);
    return;
  }

  // otherwise elbow preview
  const midX = (x1 + x) / 2;
  path.setAttribute(
    "d",
    `M ${x1} ${y1}
     L ${midX} ${y1}
     L ${midX} ${y}
     L ${x} ${y}`
  );
}

svg.addEventListener("mousemove", e => {
  if (drag) {
    drag.x = e.offsetX - BLOCK_W / 2;
    drag.rect.setAttribute("x", drag.x);
    drag.text.setAttribute("x", drag.x + BLOCK_W / 2);

    links.forEach(updateLink);
  }

  if (drawing) {
    updatePreviewLine(drawing.path, e.offsetX, e.offsetY);
  }
});

window.addEventListener("mouseup", e => {
  if (drag) {
    drag = null;
    return;
  }

  if (!drawing) return;

  const target = blocks.find(b => {
    const r = b.rect.getBBox();
    return (
      e.offsetX >= r.x &&
      e.offsetX <= r.x + r.width &&
      e.offsetY >= r.y &&
      e.offsetY <= r.y + r.height
    );
  });

  if (target && target !== drawing.from) {
    connect(drawing.from, target);
  }

  drawing.path.remove(); // remove preview
  drawing = null;
});

// Add window resize handler with debounce
let resizeTimer;
function handleResize() {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    layoutBlocks();
  }, 100);
}

window.addEventListener('resize', handleResize);

// Initial layout
setTimeout(layoutBlocks, 100);

document.getElementById("export-png").onclick = () => {
  html2canvas(document.getElementById("diagram-display")).then(c => {
    const a = document.createElement("a");
    a.download = "block-diagram.png";
    a.href = c.toDataURL();
    a.click();
  });
};

document.getElementById("add-block").onclick = () => {
  const label = document.getElementById("block-label").value;
  createBlock(label);
};

function calculateOptimalBlockWidth() {
  if (blocks.length === 0) return 100;
  
  const container = svgContainer;
  const containerWidth = container.clientWidth - 40; // Account for padding
  const minBlockWidth = 60;  // Minimum width of a block
  const gap = 10;           // Fixed gap between blocks
  
  // Calculate maximum possible width per block
  const totalGap = (blocks.length - 1) * gap;
  let blockWidth = (containerWidth - totalGap) / blocks.length;
  
  // Ensure block width is at least the minimum
  return Math.max(minBlockWidth, blockWidth);
}

function layoutBlocks() {
  if (blocks.length === 0) return;
  
  // Calculate optimal block width to fit all blocks
  BLOCK_W = calculateOptimalBlockWidth();
  
  // Calculate total width needed for all blocks and gaps
  const gap = 10; // Fixed gap between blocks
  const padding = 20; // Padding on each side
  const totalWidth = (BLOCK_W * blocks.length) + (gap * (blocks.length - 1)) + (padding * 2);
  
  // Update SVG viewBox to fit all blocks
  svg.setAttribute('viewBox', `0 0 ${totalWidth} 300`);
  
  // Position blocks
  blocks.forEach((block, index) => {
    block.x = padding + (index * (BLOCK_W + gap));
    block.rect.setAttribute('width', BLOCK_W);
    block.rect.setAttribute('x', block.x);
    block.rect.setAttribute('y', GRID_Y - (BLOCK_H / 2));
    block.text.setAttribute('x', block.x + (BLOCK_W / 2));
    block.text.setAttribute('y', GRID_Y);
  });

  // Update all links
  links.forEach(updateLink);
  
  // Ensure SVG fills its container
  svg.style.width = '100%';
  svg.style.height = '100%';
  
  // Force a reflow to ensure dimensions are updated
  const reflow = svg.offsetHeight;
}

</script>

{% endblock scripts %}